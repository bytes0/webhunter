from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import uuid
from datetime import datetime
import logging
import asyncio
import subprocess
import os
from sqlalchemy.orm import Session
from app.core.database import get_db, Scan, SessionLocal
from app.api.v1.endpoints.telegram import send_scan_notification
import sys
import shutil

router = APIRouter()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ExploitationRequest(BaseModel):
    target: str
    tool: str  # sqlmap, xsstrike, commix
    scan_type: str = "web"  # web, api, network
    options: Optional[Dict[str, Any]] = None
    custom_flags: Optional[str] = None
    delay: Optional[float] = None

class ExploitationResponse(BaseModel):
    scan_id: str
    status: str
    target: str
    tool: str
    created_at: datetime
    estimated_duration: Optional[int] = None

class ExploitationScanner:
    def __init__(self):
        self.tool_paths = {
            "sqlmap": self._find_tool_path("sqlmap"),
            "xsstrike": self._find_tool_path("xsstrike"),
            "commix": self._find_tool_path("commix")
        }
        self.available_tools = {
            tool: path is not None for tool, path in self.tool_paths.items()
        }
    
    def _find_tool_path(self, tool_name: str) -> Optional[str]:
        """Find the full path of a tool, supporting Docker and local dev."""
        docker_path = f"/app/tools/{tool_name}"
        script_filename = f"{tool_name}.py"
        if tool_name == 'xsstrike':
            script_filename = 'xsstrike.py'
        
        local_dev_path = os.path.join("backend", "tools", f"{tool_name}-dev", script_filename)

        if os.path.exists(docker_path):
            return docker_path
        elif os.path.exists(local_dev_path):
            return local_dev_path
        elif shutil.which(tool_name):
            return tool_name
        
        return None

    def _check_tool(self, tool_name: str) -> bool:
        """Check if a tool is available and executable."""
        path_to_use = self.tool_paths.get(tool_name)
        if not path_to_use:
            logger.warning(f"Tool '{tool_name}' not found in specific paths or system PATH.")
            return False

        try:
            command = []
            if path_to_use.endswith(".py"):
                command = [sys.executable, path_to_use]
            else:
                command = [path_to_use]

            if tool_name == "xsstrike":
                command.append("--help")
            else:
                command.append("--version")
            
            logger.info(f"Checking for {tool_name} with command: {' '.join(command)}")

            result = subprocess.run(
                command, 
                capture_output=True, 
                check=True, 
                text=True, 
                timeout=15
            )
            
            if result.returncode == 0:
                logger.info(f"✓ {tool_name} is available at: {path_to_use}")
                return True

        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired) as e:
            logger.warning(f"Could not confirm {tool_name} availability. It might be unavailable. Error: {e}")
            if isinstance(e, subprocess.CalledProcessError):
                logger.warning(f"Stderr for {tool_name}: {e.stderr.strip()}")
                logger.warning(f"Stdout for {tool_name}: {e.stdout.strip()}")
        except Exception as e:
            logger.error(f"An unexpected error occurred while checking for {tool_name}: {e}")
            
        return False
    
    async def run_sqlmap(self, target: str, custom_flags: Optional[str] = None, delay: Optional[float] = None) -> Dict[str, Any]:
        """Run sqlmap for SQL injection testing"""
        sqlmap_path = self.tool_paths.get("sqlmap")
        if not sqlmap_path:
            return {"error": "sqlmap executable not found."}

        try:
            logger.info(f"Running sqlmap on {target}")
            
            # Build sqlmap command
            cmd = [sqlmap_path, "-u", target, "--batch", "--random-agent"]
            
            # Add custom options
            if custom_flags:
                cmd.extend(custom_flags.split())
            if delay and delay > 0:
                cmd.extend(["--delay", str(delay)])
            
            # Add output options
            cmd.extend(["--output-dir", f"/tmp/sqlmap_{target.replace('://', '_').replace('/', '_')}"])
            
            logger.info(f"Running command: {' '.join(cmd)}")
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=600)  # 10 minutes
            
            output = stdout.decode(errors='ignore')
            error_output = stderr.decode(errors='ignore')

            logger.info(f"--- SQLmap STDOUT for {target} ---\n{output}")
            if error_output:
                logger.warning(f"--- SQLmap STDERR for {target} ---\n{error_output}")

            if process.returncode == 0:
                # Parse sqlmap results
                results = {
                    "vulnerabilities": [],
                    "injectable_parameters": [],
                    "database_info": {},
                    "raw_output": output
                }
                
                # Basic parsing of sqlmap output
                if "injectable" in output.lower():
                    results["vulnerabilities"].append({
                        "type": "SQL Injection",
                        "severity": "High",
                        "description": "SQL injection vulnerability detected",
                        "details": output
                    })
                
                logger.info(f"Sqlmap completed for {target}")
                return results
            else:
                logger.error(f"Sqlmap failed with return code {process.returncode} for {target}")
                return {"error": error_output}
                
        except asyncio.TimeoutError:
            logger.error(f"SQLmap scan timed out for {target}")
            return {"error": "Scan timed out after 10 minutes."}
        except Exception as e:
            logger.error(f"Error running sqlmap: {e}")
            return {"error": str(e)}
    
    async def run_xsstrike(self, target: str, custom_flags: Optional[str] = None, delay: Optional[float] = None) -> Dict[str, Any]:
        """Run XSStrike for XSS testing"""
        xsstrike_path = self.tool_paths.get("xsstrike")
        if not xsstrike_path:
            return {"error": "XSStrike executable not found."}

        try:
            logger.info(f"Running XSStrike on {target}")
            
            # Build XSStrike command
            cmd = [sys.executable, xsstrike_path, "-u", target, "--skip-dom"]
            
            # Add custom options
            if custom_flags:
                cmd.extend(custom_flags.split())
            if delay and delay > 0:
                cmd.extend(["--delay", str(delay)])
            
            logger.info(f"Running command: {' '.join(cmd)}")
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=300)  # 5 minutes
            
            output = stdout.decode(errors='ignore')
            error_output = stderr.decode(errors='ignore')

            logger.info(f"--- XSStrike STDOUT for {target} ---\n{output}")
            if error_output:
                logger.warning(f"--- XSStrike STDERR for {target} ---\n{error_output}")

            if process.returncode == 0:
                # Parse XSStrike results
                results = {
                    "vulnerabilities": [],
                    "xss_payloads": [],
                    "raw_output": output
                }
                
                # Basic parsing of XSStrike output
                if "vulnerable" in output.lower():
                    results["vulnerabilities"].append({
                        "type": "Cross-Site Scripting (XSS)",
                        "severity": "High",
                        "description": "XSS vulnerability detected",
                        "details": output
                    })
                
                logger.info(f"XSStrike completed for {target}")
                return results
            else:
                logger.error(f"XSStrike failed with return code {process.returncode} for {target}")
                return {"error": error_output}
                
        except asyncio.TimeoutError:
            logger.error(f"XSStrike scan timed out for {target}")
            return {"error": "Scan timed out after 5 minutes."}
        except Exception as e:
            logger.error(f"Error running XSStrike: {e}")
            return {"error": str(e)}
    
    async def run_commix(self, target: str, custom_flags: Optional[str] = None, delay: Optional[float] = None) -> Dict[str, Any]:
        """Run Commix for command injection testing"""
        commix_path = self.tool_paths.get("commix")
        if not commix_path:
            return {"error": "Commix executable not found."}
            
        try:
            logger.info(f"Running Commix on {target}")
            
            # Build Commix command
            cmd = [sys.executable, commix_path, "--url", target, "--batch"]
            
            # Add custom options
            if custom_flags:
                cmd.extend(custom_flags.split())
            if delay and delay > 0:
                cmd.extend(["--delay", str(delay)])
            
            logger.info(f"Running command: {' '.join(cmd)}")
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=300)  # 5 minutes
            
            output = stdout.decode(errors='ignore')
            error_output = stderr.decode(errors='ignore')

            logger.info(f"--- Commix STDOUT for {target} ---\n{output}")
            if error_output:
                logger.warning(f"--- Commix STDERR for {target} ---\n{error_output}")

            if process.returncode == 0:
                # Parse Commix results
                results = {
                    "vulnerabilities": [],
                    "injectable_parameters": [],
                    "raw_output": output
                }
                
                # Basic parsing of Commix output
                if "injectable" in output.lower():
                    results["vulnerabilities"].append({
                        "type": "Command Injection",
                        "severity": "Critical",
                        "description": "Command injection vulnerability detected",
                        "details": output
                    })
                
                logger.info(f"Commix completed for {target}")
                return results
            else:
                logger.error(f"Commix failed with return code {process.returncode} for {target}")
                return {"error": error_output}
                
        except asyncio.TimeoutError:
            logger.error(f"Commix scan timed out for {target}")
            return {"error": "Scan timed out after 5 minutes."}
        except Exception as e:
            logger.error(f"Error running Commix: {e}")
            return {"error": str(e)}

# Initialize scanner
scanner = ExploitationScanner()

async def run_exploitation_background(scan_id: str, target: str, tool: str, custom_flags: Optional[str] = None, delay: Optional[float] = None):
    """Asynchronous background task to run an exploitation tool."""
    db = SessionLocal()
    try:
        # Update scan status to 'running'
        scan = db.query(Scan).filter(Scan.scan_id == scan_id).first()
        if not scan:
            logger.error(f"Scan {scan_id} not found in database.")
            return

        scan.status = 'running'  # type: ignore
        db.commit()
        db.refresh(scan)

        scanner = ExploitationScanner()
        
        # Select the appropriate tool runner
        runner = None
        if tool == "sqlmap":
            runner = scanner.run_sqlmap
        elif tool == "xsstrike":
            runner = scanner.run_xsstrike
        elif tool == "commix":
            runner = scanner.run_commix
        else:
            raise ValueError(f"Unsupported tool: {tool}")
            
        logger.info(f"Starting {tool} scan for {target} with ID: {scan_id}")
        
        # Await the result from the runner
        results = await runner(target, custom_flags=custom_flags, delay=delay)
        
        # Update scan status to 'completed' and save results
        scan.status = 'completed'  # type: ignore
        scan.completed_at = datetime.utcnow()  # type: ignore
        scan.results = results  # type: ignore
        db.commit()
        db.refresh(scan)
        
        logger.info(f"Scan {scan_id} completed. Results stored.")

        # Prepare and send Telegram notification
        status_message = "✅ Exploitation Scan Completed"
        message = (
            f"*{status_message}*\\n\\n"
            f"*Scan ID:* `{scan.scan_id}`\\n"
            f"*Target:* `{scan.target}`\\n"
            f"*Tool:* `{scan.tool}`\\n"
            f"*Completed At:* `{scan.completed_at.strftime('%Y-%m-%d %H:%M:%S UTC')}`\\n\\n"
        )

        if isinstance(results, dict) and results.get('error'):
            message += f"*Result:* `Scan failed: {results['error']}`"
            await send_scan_notification("exploitation", "scan_failed", message, target)
        elif isinstance(results, dict):
            raw_output = results.get('raw_output', 'No raw output available.')
            filename = f"scan_{scan.scan_id}_{tool}_output.txt"
            
            # Save raw output to a temporary file
            with open(filename, "w", encoding="utf-8") as f:
                f.write(raw_output)

            # Send the file as a document
            await send_scan_notification("exploitation", "scan_completed", message, target, file_path=filename)
            
            # Clean up the file
            os.remove(filename)

    except Exception as e:
        logger.error(f"Error during background scan {scan_id}: {e}", exc_info=True)
        scan = db.query(Scan).filter(Scan.scan_id == scan_id).first()
        if scan:
            scan.status = 'failed'  # type: ignore
            scan.completed_at = datetime.utcnow()  # type: ignore
            scan.results = {"error": str(e)}  # type: ignore
            db.commit()
            db.refresh(scan)
            await send_scan_notification("exploitation", "scan_failed", f"⚠️ Exploitation scan `{scan_id}` failed for target `{target}`. Error: {e}", target)
    finally:
        db.close()

@router.post("/scan", response_model=ExploitationResponse)
async def start_exploitation_scan(request: ExploitationRequest, background_tasks: BackgroundTasks, db: Session = Depends(get_db)) -> ExploitationResponse:
    scanner = ExploitationScanner()
    if not scanner.available_tools.get(request.tool):
        raise HTTPException(status_code=400, detail=f"Tool '{request.tool}' is not available or not configured correctly.")

    scan_id = str(uuid.uuid4())
    new_scan = Scan(
        scan_id=scan_id,
        target=request.target,
        tool=request.tool,
        status='started',
        created_at=datetime.utcnow(),
    )
    db.add(new_scan)
    db.commit()
    db.refresh(new_scan)

    background_tasks.add_task(
        run_exploitation_background, 
        scan_id, 
        request.target, 
        request.tool,
        custom_flags=request.custom_flags,
        delay=request.delay
    )

    return ExploitationResponse(
        scan_id=scan_id,
        status='started',
        target=request.target,
        tool=request.tool,
        created_at=new_scan.created_at  # type: ignore
    )

@router.get("/scan/{scan_id}")
async def get_exploitation_scan_status(scan_id: str, db: Session = Depends(get_db)) -> Dict[str, Any]:
    """
    Get exploitation scan status
    """
    scan = db.query(Scan).filter(Scan.id == scan_id, Scan.scan_type == "exploitation").first()
    if not scan:
        raise HTTPException(status_code=404, detail="Scan not found")
    
    return {
        "scan_id": scan.id,
        "status": scan.status,
        "progress": scan.progress,
        "target": scan.target,
        "tool": scan.results.get("tool") if scan.results is not None else None,
        "created_at": scan.created_at,
        "completed_at": scan.completed_at,
        "error": scan.error,
        "results": scan.results if scan.results is not None else None
    }

@router.get("/tools")
async def list_exploitation_tools() -> Dict[str, Any]:
    """
    List available exploitation tools
    """
    return {
        "tools": [
            {
                "name": "sqlmap",
                "description": "Automated SQL injection and database takeover tool",
                "enabled": scanner.available_tools["sqlmap"],
                "capabilities": ["SQL Injection", "Database Enumeration", "Data Extraction"]
            },
            {
                "name": "xsstrike",
                "description": "Advanced XSS detection and exploitation tool",
                "enabled": scanner.available_tools["xsstrike"],
                "capabilities": ["XSS Detection", "Payload Generation", "Blind XSS"]
            },
            {
                "name": "commix",
                "description": "Automated command injection and exploitation tool",
                "enabled": scanner.available_tools["commix"],
                "capabilities": ["Command Injection", "OS Detection", "Shell Access"]
            }
        ]
    }

@router.get("/scans")
async def list_exploitation_scans(db: Session = Depends(get_db)) -> Dict[str, Any]:
    """
    List all exploitation scans
    """
    scans = db.query(Scan).filter(Scan.scan_type == "exploitation").order_by(Scan.created_at.desc()).all()
    
    scan_list = []
    for scan in scans:
        scan_list.append({
            "scan_id": scan.id,
            "target": scan.target,
            "tool": scan.results.get("tool") if scan.results is not None else None,
            "status": scan.status,
            "progress": scan.progress,
            "created_at": scan.created_at.isoformat() if scan.created_at is not None else None,
            "completed_at": scan.completed_at.isoformat() if scan.completed_at is not None else None,
            "vulnerabilities_found": scan.results.get("vulnerabilities_found", 0) if scan.results is not None else 0,
            "results": scan.results if scan.results is not None else None
        })
    
    return {
        "scans": scan_list,
        "total": len(scan_list)
    }

@router.delete("/scan/{scan_id}", status_code=204)
async def delete_exploitation_scan(scan_id: str, db: Session = Depends(get_db)):
    scan = db.query(Scan).filter(Scan.scan_id == scan_id).first()
    if not scan:
        raise HTTPException(status_code=404, detail="Scan not found")
    
    db.delete(scan)
    db.commit() 